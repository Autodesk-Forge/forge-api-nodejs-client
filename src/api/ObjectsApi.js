/**
 * Forge SDK
 * The Forge Platform contains an expanding collection of web service components that can be used with Autodesk cloud-based products or your own technologies. Take advantage of Autodesk’s expertise in design and engineering.
 *
 * OpenAPI spec version: 0.1.0
 * Contact: forge.help@autodesk.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = (function () {
	'use strict';

	var ApiClient = require('../ApiClient'),
		BucketObjects = require('../model/BucketObjects'),
		ObjectDetails = require('../model/ObjectDetails'),
		ObjectFullDetails = require('../model/ObjectFullDetails'),
		ObjectS3Download = require('../model/ObjectS3Download'),
		ObjectS3Upload = require('../model/ObjectS3Upload'),
		PostBucketsSigned = require('../model/PostBucketsSigned'),
		PostObjectSigned = require('../model/PostObjectSigned'),
		Reason = require('../model/Reason'),
		Result = require('../model/Result');

	/**
	 * Objects service.
	 * @module api/ObjectsApi
	 */

	/**
	 * Constructs a new ObjectsApi.
	 * @alias module:api/ObjectsApi
	 * @class
	 * @param {module:ApiClient} apiClient Optional API client implementation to use,
	 * default to {@link module:ApiClient#instance} if unspecified.
	 */
	var exports = function (apiClient) {
		this.apiClient = apiClient || ApiClient.instance;

		/**
		 * Copies an object to another object name in the same bucket.
		 * @param {String} bucketKey URL-encoded bucket key
		 * @param {String} objectName URL-encoded object name
		 * @param {String} newObjName URL-encoded Object key to use as the destination
		 * data is of type: {module:model/ObjectDetails}
		 * @param {Object} oauth2client oauth2client for the call
		 * @param {Object} credentials credentials for the call
		 */
		this.copyTo = function (bucketKey, objectName, newObjName, oauth2client, credentials) {
			var postBody = null;

			// verify the required parameter 'bucketKey' is set
			if (bucketKey == undefined || bucketKey == null)
				return Promise.reject("Missing the required parameter 'bucketKey' when calling copyTo");
			// verify the required parameter 'objectName' is set
			if (objectName == undefined || objectName == null)
				return Promise.reject("Missing the required parameter 'objectName' when calling copyTo");
			// verify the required parameter 'newObjName' is set
			if (newObjName == undefined || newObjName == null)
				return Promise.reject("Missing the required parameter 'newObjName' when calling copyTo");

			var pathParams = {
				'bucketKey': bucketKey,
				'objectName': objectName,
				'newObjName': newObjName
			};
			var queryParams = {};
			var headerParams = {};
			var formParams = {};

			var contentTypes = ['application/json'];
			var accepts = ['application/vnd.api+json', 'application/json'];
			var returnType = ObjectDetails;

			return this.apiClient.callApi(
				'/oss/v2/buckets/{bucketKey}/objects/{objectName}/copyto/{newObjName}', 'PUT',
				pathParams, queryParams, headerParams, formParams, postBody,
				contentTypes, accepts, returnType, oauth2client, credentials
			);
		};

		/**
		 * This endpoint creates a signed URL that can be used to download an object within the specified expiration time. Be aware that if the object the signed URL points to is deleted or expires before the signed URL expires, then the signed URL will no longer be valid. A successful call to this endpoint requires bucket owner access.
		 * @param {String} bucketKey URL-encoded bucket key
		 * @param {String} objectName URL-encoded object name
		 * @param {module:model/PostBucketsSigned} postBucketsSigned Body Structure
		 * @param {Object=} opts Optional parameters
		 * @param {String} [opts.access=read] Access for signed resource Acceptable values: `read`, `write`, `readwrite`. Default value: `read`  (default to read)
		 * data is of type: {module:model/PostObjectSigned}
		 * @param {Object} oauth2client oauth2client for the call
		 * @param {Object} credentials credentials for the call
		 */
		this.createSignedResource = function (bucketKey, objectName, postBucketsSigned, opts, oauth2client, credentials) {
			opts = opts || {};
			var postBody = postBucketsSigned;

			// verify the required parameter 'bucketKey' is set
			if (bucketKey == undefined || bucketKey == null)
				return Promise.reject("Missing the required parameter 'bucketKey' when calling createSignedResource");
			// verify the required parameter 'objectName' is set
			if (objectName == undefined || objectName == null)
				return Promise.reject("Missing the required parameter 'objectName' when calling createSignedResource");
			// verify the required parameter 'postBucketsSigned' is set
			if (postBucketsSigned == undefined || postBucketsSigned == null)
				return Promise.reject("Missing the required parameter 'postBucketsSigned' when calling createSignedResource");
			var pathParams = {
				'bucketKey': bucketKey,
				'objectName': objectName
			};
			var queryParams = {
				'access': opts.access
			};
			var headerParams = {};
			var formParams = {};

			var contentTypes = ['application/json'];
			var accepts = ['application/vnd.api+json', 'application/json'];
			var returnType = PostObjectSigned;

			return this.apiClient.callApi(
				'/oss/v2/buckets/{bucketKey}/objects/{objectName}/signed', 'POST',
				pathParams, queryParams, headerParams, formParams, postBody,
				contentTypes, accepts, returnType, oauth2client, credentials
			);
		};

		/**
		 * Deletes an object from the bucket.
		 * @param {String} bucketKey URL-encoded bucket key
		 * @param {String} objectName URL-encoded object name
		 * @param {Object} oauth2client oauth2client for the call
		 * @param {Object} credentials credentials for the call
		 */
		this.deleteObject = function (bucketKey, objectName, oauth2client, credentials) {
			var postBody = null;

			// verify the required parameter 'bucketKey' is set
			if (bucketKey == undefined || bucketKey == null)
				return Promise.reject("Missing the required parameter 'bucketKey' when calling deleteObject");
			// verify the required parameter 'objectName' is set
			if (objectName == undefined || objectName == null)
				return Promise.reject("Missing the required parameter 'objectName' when calling deleteObject");

			var pathParams = {
				'bucketKey': bucketKey,
				'objectName': objectName
			};
			var queryParams = {};
			var headerParams = {};
			var formParams = {};

			var contentTypes = ['application/json'];
			var accepts = [];
			var returnType = null;

			return this.apiClient.callApi(
				'/oss/v2/buckets/{bucketKey}/objects/{objectName}', 'DELETE',
				pathParams, queryParams, headerParams, formParams, postBody,
				contentTypes, accepts, returnType, oauth2client, credentials
			);
		};

		/**
		 * Delete a signed URL. A successful call to this endpoint requires bucket owner access.
		 * @param {String} id Id of signed resource
		 * @param {Object=} opts Optional parameters
		 * @param {String} [opts.region=US] The region where the bucket resides Acceptable values: `US`, `EMEA` Default is `US`  (default to US)
		 * @param {Object} oauth2client oauth2client for the call
		 * @param {Object} credentials credentials for the call
		 */
		this.deleteSignedResource = function (id, opts, oauth2client, credentials) {
			opts = opts || {};
			var postBody = null;

			// verify the required parameter 'id' is set
			if (id == undefined || id == null)
				return Promise.reject("Missing the required parameter 'id' when calling deleteSignedResource");

			var pathParams = {
				'id': id
			};
			var queryParams = {
				'region': opts.region || 'US'
			};
			var headerParams = {};
			var formParams = {};

			var contentTypes = ['application/json'];
			var accepts = ['text/plain'];
			var returnType = null;

			return this.apiClient.callApi(
				'/oss/v2/signedresources/{id}', 'DELETE',
				pathParams, queryParams, headerParams, formParams, postBody,
				contentTypes, accepts, returnType, oauth2client, credentials
			);
		};

		/**
		 * Download an object.
		 * @param {String} bucketKey URL-encoded bucket key
		 * @param {String} objectName URL-encoded object name
		 * @param {Object=} opts Optional parameters
		 * @param {String=} opts.range A range of bytes to download from the specified object.
		 * @param {String=} opts.ifNoneMatch The value of this header is compared to the ETAG of the object. If they match, the body will not be included in the response. Only the object information will be included.
		 * @param {Date=} opts.ifModifiedSince If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.
		 * @param {String=} opts.acceptEncoding When gzip is specified, a gzip compressed stream of the object’s bytes will be returned in the response. Cannot use “Accept-Encoding:gzip” with Range header containing an end byte range. End byte range will not be honored if “Accept-Encoding: gzip” header is used.
		 * @param {String=} opts.accepts Optional array of possible Accepts header
		 * data is of type: {Object}
		 * @param {Object} oauth2client oauth2client for the call
		 * @param {Object} credentials credentials for the call
		 * 
		 * @deprecated
		 */
		this.getObject = function (bucketKey, objectName, opts, oauth2client, credentials) {
			opts = opts || {};
			var postBody = null;

			// verify the required parameter 'bucketKey' is set
			if (bucketKey == undefined || bucketKey == null)
				return Promise.reject("Missing the required parameter 'bucketKey' when calling getObject");
			// verify the required parameter 'objectName' is set
			if (objectName == undefined || objectName == null)
				return Promise.reject("Missing the required parameter 'objectName' when calling getObject");

			var pathParams = {
				'bucketKey': bucketKey,
				'objectName': objectName
			};
			var queryParams = {};
			var headerParams = {
				'Range': opts.range || opts.Range,
				'If-None-Match': opts.ifNoneMatch,
				'If-Modified-Since': opts.ifModifiedSince,
				'Accept-Encoding': opts.acceptEncoding
			};
			var formParams = {};

			var contentTypes = ['application/json'];
			var accepts = opts.accepts || ['application/octet-stream'];
			var returnType = Object;

			return this.apiClient.callApi(
				'/oss/v2/buckets/{bucketKey}/objects/{objectName}', 'GET',
				pathParams, queryParams, headerParams, formParams, postBody,
				contentTypes, accepts, returnType, oauth2client, credentials
			);
		};

		/**
		 * Returns object details in JSON format.
		 * @param {String} bucketKey URL-encoded bucket key
		 * @param {String} objectName URL-encoded object name
		 * @param {Object=} opts Optional parameters
		 * @param {Date=} opts.ifModifiedSince If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.
		 * @param {(String|String[])=} opts._with Extra information in details; multiple uses are supported Acceptable values: `createdDate`, `lastAccessedDate`, `lastModifiedDate`
		 * data is of type: {module:model/ObjectFullDetails}
		 * @param {Object} oauth2client oauth2client for the call
		 * @param {Object} credentials credentials for the call
		 */
		this.getObjectDetails = function (bucketKey, objectName, opts, oauth2client, credentials) {
			opts = opts || {};
			var postBody = null;

			// verify the required parameter 'bucketKey' is set
			if (bucketKey == undefined || bucketKey == null)
				return Promise.reject("Missing the required parameter 'bucketKey' when calling getObjectDetails");
			// verify the required parameter 'objectName' is set
			if (objectName == undefined || objectName == null)
				return Promise.reject("Missing the required parameter 'objectName' when calling getObjectDetails");

			var pathParams = {
				'bucketKey': bucketKey,
				'objectName': objectName
			};
			var queryParams = {
				'with': opts._with
			};
			var headerParams = {
				'If-Modified-Since': opts.ifModifiedSince
			};
			var formParams = {};

			var contentTypes = ['application/json'];
			var accepts = ['application/vnd.api+json', 'application/json'];
			var returnType = ObjectFullDetails;

			return this.apiClient.callApi(
				'/oss/v2/buckets/{bucketKey}/objects/{objectName}/details', 'GET',
				pathParams, queryParams, headerParams, formParams, postBody,
				contentTypes, accepts, returnType, oauth2client, credentials
			);
		};

		/**
		 * List objects in a bucket. It is only available to the bucket creator.
		 * @param {String} bucketKey URL-encoded bucket key
		 * @param {Object=} opts Optional parameters
		 * @param {Integer} [opts.limit=10] Limit to the response size, Acceptable values: 1-100 Default = 10  (default to 10)
		 * @param {String=} opts.beginsWith Provides a way to filter the based on object key name
		 * @param {String=} opts.startAt Key to use as an offset to continue pagination This is typically the last bucket key found in a preceding GET buckets response
		 * data is of type: {module:model/BucketObjects}
		 * @param {Object} oauth2client oauth2client for the call
		 * @param {Object} credentials credentials for the call
		 */
		this.getObjects = function (bucketKey, opts, oauth2client, credentials) {
			opts = opts || {};
			var postBody = null;

			// verify the required parameter 'bucketKey' is set
			if (bucketKey == undefined || bucketKey == null)
				return Promise.reject("Missing the required parameter 'bucketKey' when calling getObjects");

			var pathParams = {
				'bucketKey': bucketKey
			};
			var queryParams = {
				'limit': opts.limit,
				'beginsWith': opts.beginsWith,
				'startAt': opts.startAt
			};
			var headerParams = {};
			var formParams = {};

			var contentTypes = ['application/json'];
			var accepts = ['application/vnd.api+json', 'application/json'];
			var returnType = BucketObjects;

			return this.apiClient.callApi(
				'/oss/v2/buckets/{bucketKey}/objects', 'GET',
				pathParams, queryParams, headerParams, formParams, postBody,
				contentTypes, accepts, returnType, oauth2client, credentials
			);
		};

		/**
		 * Download an object using a signed URL.
		 * @param {String} id Id of signed resource
		 * @param {Object=} opts Optional parameters
		 * @param {String=} opts.range A range of bytes to download from the specified object.
		 * @param {String=} opts.ifNoneMatch The value of this header is compared to the ETAG of the object. If they match, the body will not be included in the response. Only the object information will be included.
		 * @param {Date=} opts.ifModifiedSince If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message body.
		 * @param {String=} opts.acceptEncoding When gzip is specified, a gzip compressed stream of the object’s bytes will be returned in the response. Cannot use “Accept-Encoding:gzip” with Range header containing an end byte range. End byte range will not be honored if “Accept-Encoding: gzip” header is used.
		 * @param {String} [opts.region=US] The region where the bucket resides Acceptable values: `US`, `EMEA` Default is `US`  (default to US)
		 * @param {String=} opts.accepts Optional array of possible Accepts header
		 * data is of type: {Object}
		 * @param {Object} oauth2client oauth2client for the call
		 * @param {Object} credentials credentials for the call
		 * 
		 * @deprecated
		 */
		this.getSignedResource = function (id, opts, oauth2client, credentials) {
			opts = opts || {};
			var postBody = null;

			// verify the required parameter 'id' is set
			if (id == undefined || id == null)
				return Promise.reject("Missing the required parameter 'id' when calling getSignedResource");

			var pathParams = {
				'id': id
			};
			var queryParams = {
				'region': opts.region || 'US'
			};
			var headerParams = {
				'Range': opts.range || opts.Range,
				'If-None-Match': opts.ifNoneMatch,
				'If-Modified-Since': opts.ifModifiedSince,
				'Accept-Encoding': opts.acceptEncoding
			};
			var formParams = {};

			var contentTypes = ['application/json'];
			var accepts = opts.accepts || ['application/octet-stream'];
			var returnType = Object;

			return this.apiClient.callApi(
				'/oss/v2/signedresources/{id}', 'GET',
				pathParams, queryParams, headerParams, formParams, postBody,
				contentTypes, accepts, returnType, oauth2client, credentials
			);
		};

		/**
		 * This endpoint returns status information about a resumable upload.
		 * @param {String} bucketKey URL-encoded bucket key
		 * @param {String} objectName URL-encoded object name
		 * @param {String} sessionId Unique identifier of a session of a file being uploaded
		 * @param {Object} oauth2client oauth2client for the call
		 * @param {Object} credentials credentials for the call
		 */
		this.getStatusBySessionId = function (bucketKey, objectName, sessionId, oauth2client, credentials) {
			var postBody = null;

			// verify the required parameter 'bucketKey' is set
			if (bucketKey == undefined || bucketKey == null)
				return Promise.reject("Missing the required parameter 'bucketKey' when calling getStatusBySessionId");
			// verify the required parameter 'objectName' is set
			if (objectName == undefined || objectName == null)
				return Promise.reject("Missing the required parameter 'objectName' when calling getStatusBySessionId");
			// verify the required parameter 'sessionId' is set
			if (sessionId == undefined || sessionId == null)
				return Promise.reject("Missing the required parameter 'sessionId' when calling getStatusBySessionId");

			var pathParams = {
				'bucketKey': bucketKey,
				'objectName': objectName,
				'sessionId': sessionId
			};
			var queryParams = {};
			var headerParams = {};
			var formParams = {};

			var contentTypes = ['application/json'];
			var accepts = ['application/vnd.api+json', 'application/json'];
			var returnType = null;

			return this.apiClient.callApi(
				'/oss/v2/buckets/{bucketKey}/objects/{objectName}/status/{sessionId}', 'GET',
				pathParams, queryParams, headerParams, formParams, postBody,
				contentTypes, accepts, returnType, oauth2client, credentials
			);
		};

		/**
		 * This endpoint allows resumable uploads for large files in chunks.
		 * @param {String} bucketKey URL-encoded bucket key
		 * @param {String} objectName URL-encoded object name
		 * @param {Integer} contentLength Indicates the size of the request body.
		 * @param {String} contentRange Byte range of a segment being uploaded
		 * @param {String} sessionId Unique identifier of a session of a file being uploaded
		 * @param {File} body
		 * @param {Object=} opts Optional parameters
		 * @param {String=} opts.contentType Optional array of possible Content-Type header
		 * @param {String=} opts.contentDisposition The suggested default filename when downloading this object to a file after it has been uploaded.
		 * @param {String=} opts.ifMatch If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.
		 * @param {String=} opts.xAdsChunkSha1 A SHA-1 checksum of the chunk represented as a hexadecimal string. If the SHA-1 hash in the header does not match the SHA-1 hash computed by the server for the uploaded chunk, the request fails (status code 400). You can try to upload it again.
		 * data is of type: {module:model/ObjectDetails}
		 * @param {Object} oauth2client oauth2client for the call
		 * @param {Object} credentials credentials for the call
		 * 
		 * @deprecated
		 */
		this.uploadChunk = function (bucketKey, objectName, contentLength, contentRange, sessionId, body, opts, oauth2client, credentials) {
			opts = opts || {};
			var postBody = body;

			// verify the required parameter 'bucketKey' is set
			if (bucketKey == undefined || bucketKey == null)
				return Promise.reject("Missing the required parameter 'bucketKey' when calling uploadChunk");
			// verify the required parameter 'objectName' is set
			if (objectName == undefined || objectName == null)
				return Promise.reject("Missing the required parameter 'objectName' when calling uploadChunk");
			// verify the required parameter 'contentLength' is set
			if (contentLength == undefined || contentLength == null)
				return Promise.reject("Missing the required parameter 'contentLength' when calling uploadChunk");
			// verify the required parameter 'contentRange' is set
			if (contentRange == undefined || contentRange == null)
				return Promise.reject("Missing the required parameter 'contentRange' when calling uploadChunk");
			// verify the required parameter 'sessionId' is set
			if (sessionId == undefined || sessionId == null)
				return Promise.reject("Missing the required parameter 'sessionId' when calling uploadChunk");
			// verify the required parameter 'body' is set
			if (body == undefined || body == null)
				return Promise.reject("Missing the required parameter 'body' when calling uploadChunk");

			var pathParams = {
				'bucketKey': bucketKey,
				'objectName': objectName
			};
			var queryParams = {};
			var headerParams = {
				'Content-Length': contentLength,
				'Content-Range': contentRange,
				'Content-Disposition': opts.contentDisposition,
				'x-ads-chunk-sha1': opts.xAdsChunkSha1,
				'Session-Id': sessionId,
			};
			var formParams = {};

			var contentTypes = opts.contentType || ['application/octet-stream'];
			var accepts = ['application/vnd.api+json', 'application/json'];
			var returnType = ObjectDetails;

			return this.apiClient.callApi(
				'/oss/v2/buckets/{bucketKey}/objects/{objectName}/resumable', 'PUT',
				pathParams, queryParams, headerParams, formParams, postBody,
				contentTypes, accepts, returnType, oauth2client, credentials
			);
		};

		/**
		 * Upload an object. If the specified object name already exists in the bucket, the uploaded content will overwrite the existing content for the bucket name/object name combination.
		 * @param {String} bucketKey URL-encoded bucket key
		 * @param {String} objectName URL-encoded object name
		 * @param {Integer} contentLength Indicates the size of the request body.
		 * @param {File} body
		 * @param {Object=} opts Optional parameters
		 * @param {Integer=} opts.contentType Optional array of possible Content-Type header
		 * @param {String=} opts.contentDisposition The suggested default filename when downloading this object to a file after it has been uploaded.
		 * @param {String=} opts.ifMatch If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.
		 * @param {String=} opts.xAdsContentSha1 A SHA-1 checksum of the object represented as a hexadecimal string. If the SHA-1 hash in the header does not match the SHA-1 hash computed by the server for the uploaded object, the request fails (status code 400).
		 * data is of type: {module:model/ObjectDetails}
		 * @param {Object} oauth2client oauth2client for the call
		 * @param {Object} credentials credentials for the call
		 * 
		 * @deprecated
		 */
		this.uploadObject = function (bucketKey, objectName, contentLength, body, opts, oauth2client, credentials) {
			opts = opts || {};
			var postBody = body;

			// verify the required parameter 'bucketKey' is set
			if (bucketKey == undefined || bucketKey == null)
				return Promise.reject("Missing the required parameter 'bucketKey' when calling uploadObject");
			// verify the required parameter 'objectName' is set
			if (objectName == undefined || objectName == null)
				return Promise.reject("Missing the required parameter 'objectName' when calling uploadObject");
			// verify the required parameter 'contentLength' is set
			if (contentLength == undefined || contentLength == null)
				return Promise.reject("Missing the required parameter 'contentLength' when calling uploadObject");
			// verify the required parameter 'body' is set
			if (body == undefined || body == null)
				return Promise.reject("Missing the required parameter 'body' when calling uploadObject");

			var pathParams = {
				'bucketKey': bucketKey,
				'objectName': objectName
			};
			var queryParams = {};
			var headerParams = {
				'Content-Length': contentLength,
				'Content-Disposition': opts.contentDisposition,
				'If-Match': opts.ifMatch,
				'x-ads-content-sha1': opts.xAdsContentSha1,
			};
			var formParams = {};

			var contentTypes = opts.contentType || ['application/octet-stream'];
			var accepts = ['application/vnd.api+json', 'application/json'];
			var returnType = ObjectDetails;

			return this.apiClient.callApi(
				'/oss/v2/buckets/{bucketKey}/objects/{objectName}', 'PUT',
				pathParams, queryParams, headerParams, formParams, postBody,
				contentTypes, accepts, returnType, oauth2client, credentials
			);
		};

		/**
		 * Overwrite a existing object using a signed URL.  Conditions to call this operation:  Object is available Expiration period is valid Signed URL should be created with write or readwrite
		 * @param {String} id Id of signed resource
		 * @param {Integer} contentLength Indicates the size of the request body.
		 * @param {File} body
		 * @param {Object=} opts Optional parameters
		 * @param {String=} opt.contentType Optional array of possible Content-Type header
		 * @param {String=} opts.contentDisposition The suggested default filename when downloading this object to a file after it has been uploaded.
		 * @param {String} [opts.xAdsRegion=US] The region where the bucket resides Acceptable values: `US`, `EMEA` Default is `US`  (default to US)
		 * @param {String} opts.ifMatch If-Match header containing a SHA-1 hash of the bytes in the request body can be sent by the calling service or client application with the request. If present, OSS will use the value of If-Match header to verify that a SHA-1 calculated for the uploaded bytes server side matches what was sent in the header. If not, the request is failed with a status 412 Precondition Failed and the data is not written.
		 * data is of type: {module:model/ObjectDetails}
		 * @param {Object} oauth2client oauth2client for the call
		 * @param {Object} credentials credentials for the call
		 * 
		 * @deprecated
		 */
		this.uploadSignedResource = function (id, contentLength, body, opts, oauth2client, credentials) {
			opts = opts || {};
			var postBody = body;

			// verify the required parameter 'id' is set
			if (id == undefined || id == null)
				return Promise.reject("Missing the required parameter 'id' when calling uploadSignedResource");
			// verify the required parameter 'contentLength' is set
			if (contentLength == undefined || contentLength == null)
				return Promise.reject("Missing the required parameter 'contentLength' when calling uploadSignedResource");
			// verify the required parameter 'body' is set
			if (body == undefined || body == null)
				return Promise.reject("Missing the required parameter 'body' when calling uploadSignedResource");

			var pathParams = {
				'id': id
			};
			var queryParams = {};
			var headerParams = {
				'Content-Length': contentLength,
				'Content-Disposition': opts.contentDisposition,
				'x-ads-region': opts.xAdsRegion || 'US',
				'If-Match': opts.ifMatch
			};
			var formParams = {};

			var contentTypes = opts.contentType || ['application/octet-stream'];
			var accepts = ['application/vnd.api+json', 'application/json'];
			var returnType = ObjectDetails;

			return this.apiClient.callApi(
				'/oss/v2/signedresources/{id}', 'PUT',
				pathParams, queryParams, headerParams, formParams, postBody,
				contentTypes, accepts, returnType, oauth2client, credentials
			);
		};

		/**
		 * Resumable upload for signed URLs.
		 * @param {String} id Id of signed resource
		 * @param {String} contentRange Byte range of a segment being uploaded
		 * @param {String} sessionId Unique identifier of a session of a file being uploaded
		 * @param {File} body
		 * @param {Object=} opts Optional parameters
		 * @param {String=} opts.contentType Optional array of possible Content-Type header
		 * @param {String=} opts.contentDisposition The suggested default filename when downloading this object to a file after it has been uploaded.
		 * @param {String} [opts.xAdsRegion=US] The region where the bucket resides Acceptable values: `US`, `EMEA` Default is `US`  (default to US)
		 * data is of type: {module:model/ObjectDetails}
		 * @param {Object} oauth2client oauth2client for the call
		 * @param {Object} credentials credentials for the call
		 * 
		 * @deprecated
		 */
		this.uploadSignedResourcesChunk = function (id, contentRange, sessionId, body, opts, oauth2client, credentials) {
			opts = opts || {};
			var postBody = body;

			// verify the required parameter 'id' is set
			if (id == undefined || id == null)
				return Promise.reject("Missing the required parameter 'id' when calling uploadSignedResourcesChunk");
			// verify the required parameter 'contentRange' is set
			if (contentRange == undefined || contentRange == null)
				return Promise.reject("Missing the required parameter 'contentRange' when calling uploadSignedResourcesChunk");
			// verify the required parameter 'sessionId' is set
			if (sessionId == undefined || sessionId == null)
				return Promise.reject("Missing the required parameter 'sessionId' when calling uploadSignedResourcesChunk");
			// verify the required parameter 'body' is set
			if (body == undefined || body == null)
				return Promise.reject("Missing the required parameter 'body' when calling uploadSignedResourcesChunk");

			var pathParams = {
				'id': id
			};
			var queryParams = {};
			var headerParams = {
				'Content-Range': contentRange,
				'Content-Disposition': opts.contentDisposition,
				'x-ads-region': opts.xAdsRegion || 'US',
				'Session-Id': sessionId
			};
			var formParams = {};

			var contentTypes = opts.contentType || ['application/octet-stream'];
			var accepts = ['application/vnd.api+json', 'application/json'];
			var returnType = ObjectDetails;

			return this.apiClient.callApi(
				'/oss/v2/signedresources/{id}/resumable', 'PUT',
				pathParams, queryParams, headerParams, formParams, postBody,
				contentTypes, accepts, returnType, oauth2client, credentials
			);
		};

		/**
		 * Returns a signed S3 URL.
		 * @param {String} bucketKey URL-encoded bucket key
		 * @param {String} objectName URL-encoded object name to create signed URL for
		 * @param {Object=} opts Optional parameters
		 * @param {String=} opts.ifNoneMatch If the value of this header matches the ETag of the object, an entity will not be returned from the server; instead a 304 (not modified) response will be returned without any message-body.
		 * @param {Date=} opts.ifModifiedSince If the requested object has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message-body.
		 * @param {string=} opts.responseContentType Value of the Content-Type header that the client expects to receive. If this attribute is not provided, it defaults to the value corresponding to the object.
		 * @param {string=} opts.responseContentDisposition Value of the Content Disposition header the client expects to receive. If this attribute is not provided, it defaults to the value corresponding to the object.
		 * @param {string=} opts.responseCacheControl Value of the Cache-Control header that the client expects to receive. If this attribute is not provided, it defaults to the value corresponding to the object.
		 * @param {boolean=} opts.publicResourceFallback Allows fallback to OSS signed URLs in case of unmerged resumable uploads.
		 * data is of type: {module:model/ObjectS3Download}
		 * @param {Object} oauth2client oauth2client for the call
		 * @param {Object} credentials credentials for the call
		 */
		this.getS3Download = function (bucketKey, objectName, opts, oauth2client, credentials) {
			opts = opts || {};
			var postBody = null;

			// verify the required parameter 'bucketKey' is set
			if (bucketKey == undefined || bucketKey == null)
				return Promise.reject("Missing the required parameter 'bucketKey' when calling getS3Download");
			// verify the required parameter 'objectName' is set
			if (objectName == undefined || objectName == null)
				return Promise.reject("Missing the required parameter 'objectName' when calling getS3Download");

			var pathParams = {
				'bucketKey': bucketKey,
				'objectName': objectName
			};
			var queryParams = {
				'response-content-type': opts.responseContentType,
				'response-content-disposition': opts.responseContentDisposition,
				'response-cache-control': opts.responseCacheControl,
				'public-resource-fallback': opts.publicResourceFallback,
			};
			var headerParams = {
				'If-None-Match': opts.ifNoneMatch,
				'If-Modified-Since': opts.ifModifiedSince,
			};
			var formParams = {};

			var contentTypes = ['application/json'];
			var accepts = ['application/vnd.api+json', 'application/json'];
			var returnType = ObjectS3Download;

			return this.apiClient.callApi(
				'/oss/v2/buckets/{bucketKey}/objects/{objectName}/signeds3download', 'GET',
				pathParams, queryParams, headerParams, formParams, postBody,
				contentTypes, accepts, returnType, oauth2client, credentials
			);
		};

		/**
		 * Gets one or more signed URLs to objects. The signed URLs can be used to download the objects directly from S3, skipping OSS servers.
		 * Be aware that expiration time for the signed URL(s) is just 60 seconds. So, a request to the URL(s) must begin within 60 seconds; the transfer 
		 * of the data can exceed 60 seconds.
		 * A successful call to this endpoint requires bucket owner access.
		 * Note that resumable uploads store each chunk individually. After upload completes, an async process merges all the chunks and creates the 
		 * definitive OSS file. This async process can take time. If you request an S3 download URL before the async process completes, the response returns 
		 * a map of S3 URLs, one per chunk where the key is the corresponding range bytes. In case you don’t want multiple URLs in the response, you can use 
		 * OSS signed URL functionality , with the public-resource-fallback query parameter set to true.
		 * Note: While this endpoint does not support range headers, the returned URL(s) can be used for ranged downloads. This way, downloads can be 
		 * parallelized using multiple ranges for maximum speed.
		 * @param {String} bucketKey URL-encoded bucket key
		 * @param {Object} body
		 * 
		 * @param {Object[]} body.requests An array of objects representing each request to get an S3 URL to download from.
		 * @param {String} body.requests[].objectKey Object name to create a download S3 signed URL for
		 * @param {String=} body.requests[].response-content-type Value of the Content-Type header that the client expects to receive. If this attribute is not provided, it defaults to the value corresponding to the object.
		 * @param {String=} body.requests[].response-content-disposition Value of the Content Disposition header the client expects to receive. If this attribute is not provided, it defaults to the value corresponding to the object.
		 * @param {String=} body.requests[].response-cache-control Value of the Cache-Control header that the client expects to receive. If this attribute is not provided, it defaults to the value corresponding to the object.
		 * @param {String=} body.requests[].If-None-Match The value of this attribute is compared to the ETAG of the object. If they match, the response body will show the status of this item as “skipped” with the reason as “Not modified”.
		 * @param {Date=} body.requests[].If-Modified-Since If the requested object has not been modified since the time specified in this attribute, the response body will show the status of this item as “skipped” with the reason as “Not modified”.
		 * @param {Object=} opts Optional parameters
		 * @param {boolean=} opts.publicResourceFallback Allows fallback to OSS signed URLs in case of unmerged resumable uploads.
		 * data is of type: {Object.<module:model/ObjectS3Download>}
		 * @param {Object} oauth2client oauth2client for the call
		 * @param {Object} credentials credentials for the call
		 */
		this.getS3Downloads = function (bucketKey, body, opts, oauth2client, credentials) {
			opts = opts || {};
			var postBody = body;

			// verify the required parameter 'bucketKey' is set
			if (bucketKey == undefined || bucketKey == null)
				return Promise.reject("Missing the required parameter 'bucketKey' when calling getS3Downloads");
			// verify the required parameter 'body' is set
			if (body == undefined || body == null)
				return Promise.reject("Missing the required parameter 'body' when calling getS3Downloads");
			if (body.requests == undefined || body.requests == null || !Array.isArray(body.requests) || body.request.length === 0)
				return Promise.reject("Missing the required parameter 'body.requests' when calling getS3Downloads");
			for (var i = 0; i < body.requests.length; i++) {
				if (body.requests[i].objectKey == undefined || body.requests[i].objectKey == null)
					return Promise.reject("Missing the required parameter 'body.requests[].objectKey' when calling getS3Downloads");
			}

			var pathParams = {
				bucketKey: bucketKey
			};
			var queryParams = {
				'public-resource-fallback': opts.publicResourceFallback,
			};
			var headerParams = {};
			var formParams = {};

			var contentTypes = ['application/json'];
			var accepts = ['application/vnd.api+json', 'application/json'];
			var returnType = Object;

			return this.apiClient.callApi(
				'/oss/v2/buckets/{bucketKey}/objects/batchsigneds3download', 'POST',
				pathParams, queryParams, headerParams, formParams, postBody,
				contentTypes, accepts, returnType, oauth2client, credentials
			);
		};

		/**
		 * Gets a signed URL to an object, which can be used to upload it directly to S3, skipping OSS servers.
		 * @param {String} bucketKey URL-encoded bucket key
		 * @param {String} objectName URL-encoded object name to create signed URL for
		 * @param {Object=} opts Optional parameters
		 * @param {Integer} [opts.parts=1] Number of chunk to upload (default to 1 (raw upload))
		 * @param {String=} opts.uploadKey Get a new set of signed urls if the ones that were generated before have already expired and the user still needs to upload some of them.
		 * data is of type: {module:model/Object}
		 * @param {Object} oauth2client oauth2client for the call
		 * @param {Object} credentials credentials for the call
		 */
		this.getS3Upload = function (bucketKey, objectName, opts, oauth2client, credentials) {
			opts = opts || {};
			var postBody = null;

			// verify the required parameter 'bucketKey' is set
			if (bucketKey == undefined || bucketKey == null)
				return Promise.reject("Missing the required parameter 'bucketKey' when calling getS3Upload");
			// verify the required parameter 'objectName' is set
			if (objectName == undefined || objectName == null)
				return Promise.reject("Missing the required parameter 'objectName' when calling getS3Upload");

			var pathParams = {
				'bucketKey': bucketKey,
				'objectName': objectName
			};
			var queryParams = {
				parts: opts.parts || 1,
				uploadKey: opts.uploadKey,
			};
			var headerParams = {};
			var formParams = {};

			var contentTypes = ['application/json'];
			var accepts = ['application/vnd.api+json', 'application/json'];
			var returnType = Object;

			return this.apiClient.callApi(
				'/oss/v2/buckets/{bucketKey}/objects/{objectName}/signeds3upload', 'GET',
				pathParams, queryParams, headerParams, formParams, postBody,
				contentTypes, accepts, returnType, oauth2client, credentials
			);
		};

		/**
		 * Gets a signed URL to an object, which can be used to upload it directly to S3, skipping OSS servers.
		 * @param {String} bucketKey URL-encoded bucket key
		 * @param {String} objectName URL-encoded object name to create signed URL for
		 * @param {String=} uploadKey -
		 * @param {Object=} opts Optional parameters
		 * @param {Integer=} opts.size Full expected object size
		 * @param {String[]=} opts.eTags Collected part eTags
		 * @param {String=} opts.x-ads-meta-Content-Type -
		 * @param {String=} opts.x-ads-meta-Content-Disposition -
		 * @param {String=} opts.x-ads-meta-Content-Encoding -
		 * @param {String=} opts.x-ads-meta-Cache-Control -
		 * data is of type: {module:model/Object}
		 * @param {Object} oauth2client oauth2client for the call
		 * @param {Object} credentials credentials for the call
		 */
		this.completeS3Upload = function (bucketKey, objectName, uploadKey, opts, oauth2client, credentials) {
			opts = opts || {};

			// verify the required parameter 'bucketKey' is set
			if (bucketKey == undefined || bucketKey == null)
				return Promise.reject("Missing the required parameter 'bucketKey' when calling completeS3Upload");
			// verify the required parameter 'objectName' is set
			if (objectName == undefined || objectName == null)
				return Promise.reject("Missing the required parameter 'objectName' when calling completeS3Upload");
			// verify the required parameter 'uploadKey' is set
			if (uploadKey == undefined || uploadKey == null)
				return Promise.reject("Missing the required parameter 'uploadKey' when calling completeS3Upload");

			var postBody = {
				uploadKey: uploadKey,
				size: opts.size,
				eTags: eTags,
			};

			var pathParams = {
				'bucketKey': bucketKey,
				'objectName': objectName
			};
			var queryParams = {
				parts: opts.parts || 1,
				uploadKey: opts.uploadKey,
			};
			var headerParams = {};
			var formParams = {};

			var contentTypes = ['application/json'];
			var accepts = ['application/vnd.api+json', 'application/json'];
			var returnType = Object;

			return this.apiClient.callApi(
				'/oss/v2/buckets/{bucketKey}/objects/{objectName}/signeds3upload', 'POST',
				pathParams, queryParams, headerParams, formParams, postBody,
				contentTypes, accepts, returnType, oauth2client, credentials
			);
		};

		// Workflow implementations

		/**
		 * Download a resource.
		 * @param {String} bucketKey URL-encoded bucket key
		 * @param {String} objectName URL-encoded object name
		 * @param {Object=} opts Optional parameters
		 * data is of type: {Object}
		 * @param {Object} oauth2client oauth2client for the call
		 * @param {Object} credentials credentials for the call
		 */
		this.downloadResource = function (bucketKey, objectName, opts, auth2client, credentials) {
			opts = opts || {};
			if (!bucketKey)
				return Promise.reject("Missing the required parameter 'bucketKey' when calling uploadResource");
			if (!objectName)
				return Promise.reject("Missing the required parameter 'objectName' when calling uploadResource");

		};

		/**
		 * Upload a resource. If the specified object name already exists in the bucket, the uploaded content will overwrite the existing content for the bucket name/object name combination.
		 * @param {String} bucketKey URL-encoded bucket key
		 * @param {String} objectName URL-encoded object name
		 * @param {File} content
		 * @param {Object=} opts Optional parameters
		 * data is of type: {module:model/ObjectDetails}
		 * @param {Object} oauth2client oauth2client for the call
		 * @param {Object} credentials credentials for the call
		 */
		this.uploadResource = function (bucketKey, objectName, content, opts, auth2client, credentials) {
			var chunkSize = 5 * 1024 * 1024; // 5Mb
			var minChunkSize = 2 * 1024 * 1024; // 2Mb

			opts = opts || {};
			if (!bucketKey)
				return Promise.reject("Missing the required parameter 'bucketKey' when calling uploadResource");
			if (!objectName)
				return Promise.reject("Missing the required parameter 'objectName' when calling uploadResource");
			if (!content)
				return Promise.reject("Missing the required parameter 'content' when calling uploadResource");

			var size = content.length; // string, Buffer, stream
			if ( size <= chunkSize )
				return (this.uploadObject(bucketKey, objectName, size, content, opts, auth2client, credentials));

			var nb = Math.floor(size / chunkSize);
			if ((size % chunkSize) !== 0)
				nb++;
			var arr = [];
			var uuid = uuidv4();
			for (var i = 0; i < nb; i++) {
				var start = i * chunkSize;
				var end = start + chunkSize - 1;
				if (end > size - 1)
					end = size - 1;
				var range = {
					ContentRange: 'bytes ' + start + '-' + end + '/' + size,
					size: end - start + 1,
					start: start,
					end: end,
				};
				arr.push({ range: range, sessionId: uuid });
			}

			return (utils.promiseSerie(arr, (item, index) => { // eslint-disable-line no-unused-vars
				return (new Promise((fulfill, reject) => {
					// If still in parallel, but results processed in series with 'utils.promiseSerie', use item.then()
					this.uploadChunk(
						bucketKey,
						objectName,
						item.range.size,
						item.range.ContentRange,
						item.sessionId,
						rstream,
						{ xAdsRegion: opts.region || opts.xAdsRegion }
					)
						.then((content) => {
							if (content.statusCode === 202)
								return (fulfill(item.opts.ContentRange));
							fulfill(content);
						})
						.catch((error) => {
							reject(error);
						});
				}));
			}));

		};

	};

	return exports;
}());